# Aliases
alias k="kubectl"
alias kx=$(which kubectx)
alias kn=$(which kubens)
alias ke="kubectl exec -it"
alias kl="kubectl logs"
alias kg="kubectl get"
alias ktn="kubectl top no --use-protocol-buffers"
alias ktp="kubectl top pod --use-protocol-buffers"
alias kd="kubectl describe"
alias kni="kubectl get nodes -o=custom-columns=NODE:.metadata.name,MAX_PODS:.status.allocatable.pods,CAPACITY_PODS:.status.capacity.pods,INSTANCE_TYPE:.metadata.labels.\"node\.kubernetes\.io/instance-type\",ARCH:.status.nodeInfo.architecture,NODE_NAME:.metadata.labels.\"kubernetes\.io/hostname\""
alias kgn="kg nodes"
alias kgp="kg pods"
alias kgpa="kgp -A"
alias kgpw="kgp -owide"
alias kgd="kg deployment"
alias kgr="kg rollout"
alias kdp="kd pods"
alias kdd="kd deployment"
alias kdr="kd rollout"
alias kdds="kd daemonset"
alias kgpn="kgp --output=jsonpath={.items..metadata.name}"

# Helper Functions (internal)
function _k8s_find_resource() {
    # Generic function to find a k8s resource by pattern
    # Usage: _k8s_find_resource "pods|deployments|statefulsets" "pattern"
    local resource_type="$1"
    local pattern="$2"
    kubectl get "$resource_type" | grep "$pattern" | awk '{print $1}' | head -n1
}

function _k8s_find_pod() {
    # Find a pod by pattern, returns pod name or empty string
    _k8s_find_resource "pods" "$1"
}

function _k8s_find_deployment() {
    # Find a deployment by pattern, returns deployment name or empty string
    _k8s_find_resource "deployments" "$1"
}

function _k8s_find_statefulset() {
    # Find a statefulset by pattern, returns statefulset name or empty string
    _k8s_find_resource "statefulsets" "$1"
}

function _k8s_find_namespace() {
    # Find a namespace by pattern, returns namespace name or empty string
    kubens | grep "$1" | head -n1
}

function _k8s_get_first_container() {
    # Get the first container name from a pod
    # Usage: _k8s_get_first_container "pod-name"
    kubectl get pod "$1" -o jsonpath='{.spec.containers[0].name}'
}

# Functions
function kxg() {
    if [[ -z "$1" ]]; then
        echo "Usage: kxg <pattern1> [pattern2] [pattern3] ..."
        return 1
    fi

    local result=$(kubectx)

    # Loop through all arguments and chain greps
    for pattern in "$@"; do
        result=$(echo "$result" | grep "$pattern")
    done

    # Get the first result
    local context_name=$(echo "$result" | head -n1)

    if [[ -n "$context_name" ]]; then
        kubectx "$context_name"
    else
        echo "Error: Context not found matching pattern(s): $*"
        return 1
    fi
}

function kng() {
    local namespace_name=$(_k8s_find_namespace "$1")
    if [[ -n "$namespace_name" ]]; then
        kubens "$namespace_name"
    else
        echo "Error: Namespace not found matching pattern: $1"
        return 1
    fi
}

function kxng() {
    if [[ -z "$1" ]]; then
        echo "Usage: kxng <context-pattern> <namespace-pattern>"
        return 1
    fi

    kxg "$1"
    if [[ -n "$2" ]]; then
        kng "$2"
    fi
}

function krcx() {
    echo "Removing current k8s context and namespace..."
    kubectl config unset current-context
}

function kep() {
    local pod_name=$(_k8s_find_pod "$1")
    if [[ -n "$pod_name" ]]; then
        if [[ -n "$2" ]]; then
            kubectl exec -it "$pod_name" -- "$2"
        else
            kubectl exec -it "$pod_name" -- sh -c "clear; echo 'Exec pod: $pod_name'; bash || sh"
        fi
    else
        echo "Error: Pod not found matching pattern: $1"
        return 1
    fi
}

function skctl() {
    current_context=$(kubectl config current-context)
    current_namespace=$(kubectl config view --minify --output 'jsonpath={..namespace}')

    echo "Current Kubernetes context: $current_context"
    echo "Current namespace: $current_namespace"
}


function kchk() {
  local contexts=$(kubectx)

  # If a pattern is provided, filter contexts
  if [[ -n "$1" ]]; then
    contexts=$(echo "$contexts" | grep "$1")
  fi

  echo "$contexts" | while read -r eachContext
  do
    if [[ -n "$eachContext" ]]; then
      echo "=== $eachContext ==="
      kubectl get pods --context="$eachContext" -A | grep -Ev 'Running|Completed|Terminating|ContainerCreating|Init:'
    fi
  done
}

function klg() {
    local pod_name=$(_k8s_find_pod "$1")
    if [[ -n "$pod_name" ]]; then
        if [[ -n "$2" ]]; then
            kubectl logs "$pod_name" "$2"
        else
            # Get the first container name if multiple containers exist
            local first_container_name=$(_k8s_get_first_container "$pod_name")
            kubectl logs "$pod_name" -c "$first_container_name"
        fi
    else
        echo "Error: Pod not found matching pattern: $1"
        return 1
    fi
}

function kdg() {
    local pod_name=$(_k8s_find_pod "$1")
    if [[ -n "$pod_name" ]]; then
        kubectl describe pod "$pod_name"
    else
        echo "Error: Pod not found matching pattern: $1"
        return 1
    fi
}

function kroll() {
    local deployment_name=$(_k8s_find_deployment "$1")
    if [[ -n "$deployment_name" ]]; then
        kubectl rollout restart deployment "$deployment_name"
    else
        local statefulset_name=$(_k8s_find_statefulset "$1")
        if [[ -n "$statefulset_name" ]]; then
            kubectl rollout restart statefulset "$statefulset_name"
        else
            echo "Error: Deployment or StatefulSet not found matching pattern: $1"
            return 1
        fi
    fi
}

function kdebug() {
    if [[ -z "$1" ]]; then
        echo "Usage: kdebug <pod-pattern> [container-name]"
        return 1
    fi

    # Find matching pod
    local pod_name=$(_k8s_find_pod "$1")
    if [[ -z "$pod_name" ]]; then
        echo "Pod not found."
        return 1
    fi

    # Determine container name
    local container_name
    if [[ -n "$2" ]]; then
        container_name="$2"
    else
        container_name=$(_k8s_get_first_container "$pod_name")
    fi

    # Define debug pod name
    local debug_pod_name="debug-${pod_name}"

    # Check if debug pod already exists and delete it
    if kubectl get pod "$debug_pod_name" &>/dev/null; then
        echo "Warning: Debug pod '$debug_pod_name' already exists. Deleting..."
        kubectl delete pod "$debug_pod_name" --wait=false
        sleep 2
    fi

    # Create debug pod using kubectl debug
    echo "Creating debug pod '$debug_pod_name' from '$pod_name'..."
    kubectl debug "$pod_name" \
        --copy-to="$debug_pod_name" \
        --container="$container_name" \
        --same-node=false \
        --keep-labels=false \
        --keep-liveness=false \
        --keep-readiness=false \
        --keep-startup=false \
        -- sh -c 'while true; do echo "Debug pod running - $(date)"; sleep 5; done'

    if [[ $? -eq 0 ]]; then
        echo ""
        echo "Debug pod created successfully!"
    else
        echo "Failed to create debug pod."
        return 1
    fi
}

function rfe() {
    if [[ -z "$1" ]] || [[ -z "$2" ]]; then
        echo "Usage: rfe <context-pattern> <namespace-pattern> <command...>"
        echo "Example: rfe eks-main-green async kubectl get pods"
        return 1
    fi

    local context_pattern="$1"
    local namespace_pattern="$2"
    shift 2
    local command="$@"

    if [[ -z "$command" ]]; then
        echo "Error: No command provided"
        return 1
    fi

    # Get all contexts matching the pattern
    local contexts=$(kubectx | grep "$context_pattern")

    if [[ -z "$contexts" ]]; then
        echo "No contexts found matching pattern: $context_pattern"
        return 1
    fi

    echo "$contexts" | while read -r context
    do
        if [[ -n "$context" ]]; then
            echo "------------------------------"
            echo "Context: $context"

            # Switch to the context
            kubectx "$context" > /dev/null

            # Get all namespaces matching the pattern
            local namespaces=$(kubens | grep "$namespace_pattern")

            if [[ -z "$namespaces" ]]; then
                echo "  No namespaces found matching pattern: $namespace_pattern"
                continue
            fi

            echo "$namespaces" | while read -r namespace
            do
                if [[ -n "$namespace" ]]; then
                    echo "Namespace: $namespace"

                    kubens "$namespace" > /dev/null
                    echo "------------------------------"
                    
                    echo ""
                    eval "$command"
                    echo ""
                fi
            done
        fi
    done
}
